#!/usr/bin/env ts-node

/**
 * Test Generation Script
 *
 * Generates Playwright test specs from JSON test cases
 */

import * as fs from 'fs'
import * as path from 'path'
import { Logger } from './logger'

const logger = new Logger('Test Generation')

interface TestStep {
	order: number
	description: string
	action: string
	locator?: string
	value?: string
}

interface TestCase {
	id: string
	suite: string
	title: string
	type: 'Happy Path' | 'Negative' | 'Edge Case'
	priority: 'High' | 'Medium' | 'Low'
	preconditions: string
	steps: TestStep[]
	expectedResult: string
	testData: Record<string, any>
	status: 'Not Run' | 'Pass' | 'Fail' | 'Flaky'
	comments: string
}

interface TestSuiteJSON {
	name: string
	url: string
	description: string
	timestamp: string
	analysis?: {
		pageType?: string
		complexity?: string
		recommendedTestCount?: string
	}
	positiveCases?: TestCase[]
	negativeCases?: TestCase[]
	edgeCases?: TestCase[]
	testCases?: TestCase[] // Legacy format support
}

/**
 * Parse JSON test cases file
 */
function loadTestCases(jsonPath: string): {
	suite: TestSuiteJSON
	allTests: TestCase[]
} {
	logger.progress(`ðŸ“– Loading test cases from: ${jsonPath}`)

	if (!fs.existsSync(jsonPath)) {
		logger.error(`File not found: ${jsonPath}`)
		process.exit(1)
	}

	const content = fs.readFileSync(jsonPath, 'utf-8')
	const testSuite: TestSuiteJSON = JSON.parse(content)

	// Support both new AI format (positiveCases/negativeCases/edgeCases) and legacy format (testCases)
	let allTests: TestCase[] = []

	if (
		testSuite.positiveCases ||
		testSuite.negativeCases ||
		testSuite.edgeCases
	) {
		// New AI-generated format
		allTests = [
			...(testSuite.positiveCases || []),
			...(testSuite.negativeCases || []),
			...(testSuite.edgeCases || []),
		]
		logger.info('Detected AI-generated test format')
	} else if (testSuite.testCases) {
		// Legacy format
		allTests = testSuite.testCases
		logger.info('Detected legacy test format')
	}

	if (allTests.length === 0) {
		logger.error('No test cases found in JSON file')
		logger.warn(
			'Expected format: positiveCases, negativeCases, edgeCases arrays',
		)
		process.exit(1)
	}

	logger.success(`âœ“ Loaded ${allTests.length} test cases`)

	if (
		testSuite.positiveCases ||
		testSuite.negativeCases ||
		testSuite.edgeCases
	) {
		logger.bullet(`  âœ“ Positive: ${testSuite.positiveCases?.length || 0}`)
		logger.bullet(`  âœ— Negative: ${testSuite.negativeCases?.length || 0}`)
		logger.bullet(`  âš  Edge: ${testSuite.edgeCases?.length || 0}`)
	}

	return { suite: testSuite, allTests }
}

/**
 * Map step action to Playwright code
 */
function mapActionToPlaywright(step: TestStep): string {
	const { action, locator, value } = step

	// Escape single quotes in values for code generation
	const escapeValue = (v: string | undefined) => v?.replace(/'/g, "\\'") || ''

	switch (action.toLowerCase()) {
		case 'fill':
			return `await page.locator('${locator}').fill('${escapeValue(value)}')`
		case 'click':
			return `await page.locator('${locator}').click()`
		case 'check':
			return `await page.locator('${locator}').check()`
		case 'uncheck':
			return `await page.locator('${locator}').uncheck()`
		case 'select':
			return `await page.locator('${locator}').selectOption('${escapeValue(
				value,
			)}')`
		case 'type':
			return `await page.locator('${locator}').type('${escapeValue(value)}')`
		case 'wait':
			return `await page.waitForTimeout(${value || 1000})`
		case 'navigate':
			return `await page.goto('${value}')`
		case 'assert_visible':
			return `await expect(page.locator('${locator}')).toBeVisible()`
		case 'assert_text':
			return `await expect(page.locator('${locator}')).toContainText('${escapeValue(
				value,
			)}')`
		case 'assert_url':
			return `await expect(page).toHaveURL(/${escapeValue(value)}/)`
		case 'assert_enabled':
			return `await expect(page.locator('${locator}')).toBeEnabled()`
		case 'assert_disabled':
			return `await expect(page.locator('${locator}')).toBeDisabled()`
		case 'hover':
			return `await page.locator('${locator}').hover()`
		case 'press':
			return `await page.keyboard.press('${value}')`
		default:
			logger.warn(`Unknown action: ${action}`)
			return `// TODO: Implement action: ${action} on ${locator}`
	}
}

/**
 * Generate test file content from test cases
 */
function generateTestContent(
	testSuite: TestSuiteJSON,
	allTests: TestCase[],
): string {
	const timestamp = new Date().toISOString()

	const importSection = `import { test, expect } from '@playwright/test'

/**
 * ${testSuite.name} - Test Suite
 * 
 * Auto-generated by AI Test Generator
 * Generated: ${timestamp}
 * URL: ${testSuite.url}
 * Total Tests: ${allTests.length}
 */

test.describe('${testSuite.name}', () => {
  test.beforeEach(async ({ page }) => {
    // Navigate to base URL before each test
    await page.goto('${testSuite.url}')
  })

`

	// Generate tests grouped by type
	const testsByType = {
		'Happy Path': allTests.filter((tc) => tc.type === 'Happy Path'),
		Negative: allTests.filter((tc) => tc.type === 'Negative'),
		'Edge Case': allTests.filter((tc) => tc.type === 'Edge Case'),
	}

	let testContent = ''

	Object.entries(testsByType).forEach(([type, tests]) => {
		if (tests.length === 0) return

		testContent += `  // ==========================================\n`
		testContent += `  // ${type} Tests (${tests.length})\n`
		testContent += `  // ==========================================\n\n`

		tests.forEach((tc) => {
			const steps = tc.steps
				.sort((a, b) => a.order - b.order)
				.map((step) => {
					const action = mapActionToPlaywright(step)
					const comment = step.description ? `// ${step.description}` : ''
					return comment ? `    ${comment}\n    ${action}` : `    ${action}`
				})
				.join('\n\n')

			const testTitle = tc.title.replace(/'/g, "\\'")
			const tags =
				tc.priority === 'High'
					? '@critical'
					: tc.priority === 'Medium'
					? '@medium'
					: '@low'

			testContent += `  test('${tc.id} - ${testTitle} ${tags}', async ({ page }) => {
    /**
     * Type: ${tc.type}
     * Priority: ${tc.priority}
     * Preconditions: ${tc.preconditions}
     * Expected: ${tc.expectedResult}
     */

${steps}

    // Test completed successfully
    console.log('âœ“ ${tc.id}: ${tc.expectedResult}')
  })

`
		})
	})

	const closingSection = `})\n`

	return importSection + testContent + closingSection
}

/**
 * Generate test spec files from JSON test cases
 */
async function generateTestSpecs(
	jsonPath: string,
	suiteName: string,
): Promise<void> {
	logger.header('ðŸ§ª GENERATING TEST SPECIFICATIONS')

	// Load test cases from JSON
	const { suite, allTests } = loadTestCases(jsonPath)

	logger.info(`Suite: ${suite.name}`)
	logger.info(`URL: ${suite.url}`)
	logger.info(`Description: ${suite.description}`)

	if (suite.analysis) {
		logger.section('AI Analysis')
		logger.bullet(`Page Type: ${suite.analysis.pageType || 'N/A'}`)
		logger.bullet(`Complexity: ${suite.analysis.complexity || 'N/A'}`)
		if (suite.analysis.recommendedTestCount) {
			logger.info(`Reasoning: ${suite.analysis.recommendedTestCount}`)
		}
	}

	// Generate test content
	logger.progress('Generating Playwright test specs...')
	const testContent = generateTestContent(suite, allTests)

	// Create test directory
	const testDir = path.join(process.cwd(), 'tests', 'test-cases')
	if (!fs.existsSync(testDir)) {
		fs.mkdirSync(testDir, { recursive: true })
		logger.progress('Created tests/test-cases directory')
	}

	// Write test file
	const testFile = path.join(testDir, `${suiteName}.spec.ts`)
	fs.writeFileSync(testFile, testContent, 'utf-8')

	logger.success(`âœ“ Test spec generated: ${testFile}`)

	// Show breakdown
	logger.section('Test Case Summary')
	const happy = allTests.filter((tc) => tc.type === 'Happy Path').length
	const negative = allTests.filter((tc) => tc.type === 'Negative').length
	const edge = allTests.filter((tc) => tc.type === 'Edge Case').length

	logger.bullet(`Total: ${allTests.length} tests`)
	logger.bullet(`âœ“ Happy Path: ${happy} tests`)
	logger.bullet(`âœ— Negative: ${negative} tests`)
	logger.bullet(`âš  Edge Cases: ${edge} tests`)

	// Show priority breakdown
	const high = allTests.filter((tc) => tc.priority === 'High').length
	const medium = allTests.filter((tc) => tc.priority === 'Medium').length
	const low = allTests.filter((tc) => tc.priority === 'Low').length

	logger.section('Priority Distribution')
	logger.bullet(`ðŸ”´ High: ${high} tests`)
	logger.bullet(`ðŸŸ¡ Medium: ${medium} tests`)
	logger.bullet(`ðŸŸ¢ Low: ${low} tests`)

	logger.complete(2)
}

// CLI Interface
const args = process.argv.slice(2)
const jsonIndex = args.indexOf('--json')
const suiteIndex = args.indexOf('--suite')

if (jsonIndex === -1 || suiteIndex === -1) {
	logger.error('Missing required arguments')
	logger.info(
		'Usage: ts-node scripts/generate-tests.ts --json <PATH> --suite <NAME>',
	)
	logger.info('')
	logger.info('Example:')
	logger.info(
		'  npm run generate:tests -- --json "test-suites/Login_Page-test-cases.json" --suite "Login_Page"',
	)
	process.exit(1)
}

const jsonPath: string | undefined = args[jsonIndex + 1]
const suite = args[suiteIndex + 1]

if (!jsonPath || !suite) {
	logger.error('JSON path and suite name are required')
	process.exit(1)
}

generateTestSpecs(jsonPath, suite).catch((error) => {
	logger.error(`Failed to generate tests: ${error.message}`)
	console.error(error.stack)
	process.exit(1)
})
